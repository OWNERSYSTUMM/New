import re
import requests
from pyrogram import Client, filters
from pyrogram.types import Message
import os
from SystemMusic import app 

# RapidAPI credentials from your request
RAPIDAPI_KEY = "5186f41cd7msh12b599090d738a1p18018bjsn59f5cc3db94f"
RAPIDAPI_HOST = "instagram-scraper-stable-api.p.rapidapi.com"
INSTA_API_URL = "https://instagram-scraper-stable-api.p.rapidapi.com/get_media_data_v2.php"

# Headers for RapidAPI
headers = {
    "x-rapidapi-key": RAPIDAPI_KEY,
    "x-rapidapi-host": RAPIDAPI_HOST
}

# Initialize the Pyrogram client
app = Client("insta_downloader_bot", api_id=api_id, api_hash=api_hash, bot_token=bot_token)

# Regex to validate and extract Instagram post shortcode
INSTA_URL_REGEX = r"https?://(www\.)?instagram\.com/(p|reel)/([A-Za-z0-9_-]+)/?"

# Start command handler
@app.on_message(filters.command("start"))
async def start(client: Client, message: Message):
    await message.reply_text(
        "Hello! I'm an Instagram Downloader Bot. Send me an Instagram post or reel URL (e.g., https://www.instagram.com/p/DE5qYzkTQsv/) to download the media."
    )

# Help command handler
@app.on_message(filters.command("help"))
async def help_command(client: Client, message: Message):
    await message.reply_text(
        "How to use me:\n"
        "- Send an Instagram post or reel URL (e.g., https://www.instagram.com/p/DE5qYzkTQsv/).\n"
        "- I'll download the media and send it back to you.\n"
        "Note: Only public posts are supported. Ensure the URL is valid."
    )

# Handler for messages containing Instagram URLs
@app.on_message(filters.text & filters.private)
async def handle_url(client: Client, message: Message):
    url = message.text.strip()
    
    # Validate and extract shortcode from Instagram URL
    match = re.match(INSTA_URL_REGEX, url)
    if not match:
        await message.reply_text("Please send a valid Instagram post or reel URL (e.g., https://www.instagram.com/p/DE5qYzkTQsv/).")
        return
    
    media_code = match.group(3)  # Extract shortcode (e.g., DE5qYzkTQsv)
    
    try:
        # Call the RapidAPI Instagram Scraper
        response = requests.get(
            INSTA_API_URL,
            headers=headers,
            params={"media_code": media_code},
            timeout=10
        )
        response.raise_for_status()
        data = response.json()

        # Check API response (adjust based on actual API response structure)
        if data.get("status") == "success" and data.get("media"):
            media_items = data["media"]  # Assuming media is a list of URLs or objects
            
            for item in media_items:
                media_url = item.get("url") if isinstance(item, dict) else item
                if not media_url:
                    continue
                
                # Determine media type from URL extension
                file_extension = media_url.split(".")[-1].split("?")[0].lower()
                
                # Download the media
                media_response = requests.get(media_url, stream=True, timeout=10)
                media_response.raise_for_status()
                
                # Save media to a temporary file
                file_name = f"temp_media_{media_code}.{file_extension}"
                with open(file_name, "wb") as f:
                    for chunk in media_response.iter_content(chunk_size=8192):
                        f.write(chunk)
                
                # Send media to user based on type
                try:
                    if file_extension in ["jpg", "jpeg", "png"]:
                        await message.reply_photo(file_name, caption="Here’s your Instagram media!")
                    elif file_extension in ["mp4", "mov"]:
                        await message.reply_video(file_name, caption="Here’s your Instagram video!")

else:
                        await message.reply_document(file_name, caption="Here’s your Instagram media!")
                finally:
                    # Clean up temporary file
                    if os.path.exists(file_name):
                        os.remove(file_name)
        
        else:
            error_message = data.get("message", "Failed to fetch media. The post may be private or the URL is invalid.")
            await message.reply_text(error_message)

    except requests.RequestException as e:
        await message.reply_text(f"Error fetching media: {str(e)}")
    except Exception as e:
        await message.reply_text(f"An unexpected error occurred: {str(e)}")
